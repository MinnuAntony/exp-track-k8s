name: CI-CD to Kubernetes
on:
  push:
    branches:
      - main
  workflow_dispatch:
jobs:
  # ---------------- JOB 1: BUILD & PUSH IMAGES ----------------
  build:
    runs-on: self-hosted
    outputs:
      expense_image: ${{ steps.expense.outputs.expense_image }}
      user_image: ${{ steps.user.outputs.user_image }}
      frontend_image: ${{ steps.frontend.outputs.frontend_image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Log in to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Get Git SHA
        id: sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
      - name: Build and Push Expense Service Image
        id: expense
        run: |
          IMAGE="${{ secrets.DOCKER_USERNAME }}/expense-service:${{ steps.sha.outputs.sha }}"
          echo "Building Expense Service Image: $IMAGE"
          docker build -t "$IMAGE" ./expense-service
          docker push "$IMAGE"
          echo "expense_image=$IMAGE" >> $GITHUB_OUTPUT
      - name: Build and Push User Service Image
        id: user
        run: |
          IMAGE="${{ secrets.DOCKER_USERNAME }}/user-service:${{ steps.sha.outputs.sha }}"
          echo "Building User Service Image: $IMAGE"
          docker build -t "$IMAGE" ./user-service
          docker push "$IMAGE"
          echo "user_image=$IMAGE" >> $GITHUB_OUTPUT
      - name: Build and Push Frontend Image
        id: frontend
        run: |
          IMAGE="${{ secrets.DOCKER_USERNAME }}/frontend-new:${{ steps.sha.outputs.sha }}"
          echo "Building Frontend Image: $IMAGE"
          docker build -t "$IMAGE" ./frontend-new
          docker push "$IMAGE"
          echo "frontend_image=$IMAGE" >> $GITHUB_OUTPUT

  # ---------------- JOB 2: DEPLOY TO KUBERNETES ----------------
  deploy:
    runs-on: self-hosted
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      # ---------------- INGRESS CONTROLLER ----------------
      - name: Install NGINX Ingress Controller
        run: |
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml
          kubectl wait --namespace ingress-nginx \
            --for=condition=available deployment ingress-nginx-controller \
            --timeout=180s
      - name: Patch Ingress Controller Service to NodePort
        run: |
          kubectl get svc ingress-nginx-controller -n ingress-nginx -o yaml \
            | sed 's/type: LoadBalancer/type: NodePort/' \
            | kubectl apply -f -
      # ---------------- METRICS SERVER ----------------
      - name: Install Metrics Server
        run: |
          kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
          kubectl wait --namespace kube-system \
            --for=condition=available deployment metrics-server \
            --timeout=120s
      - name: Patch Metrics Server
        run: |
          kubectl -n kube-system patch deployment metrics-server --type='json' \
            -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-insecure-tls"}]' || true
          kubectl -n kube-system rollout status deployment/metrics-server --timeout=120s || true
      # ---------------- MYSQL SECRET ----------------
      - name: Create MySQL Secret
        run: |
          kubectl delete secret mysql-secret --ignore-not-found
          kubectl create secret generic mysql-secret \
            --from-literal=MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}" \
            --from-literal=MYSQL_USER="${{ secrets.MYSQL_USER }}" \
            --from-literal=MYSQL_PASSWORD="${{ secrets.MYSQL_PASSWORD }}" \
            --from-literal=MYSQL_DATABASE="${{ secrets.MYSQL_DATABASE }}"
      # ---------------- UPDATE DEPLOYMENT IMAGES ----------------
      - name: Update Deployment Images
        run: |
          echo "Updating deployments with new images..."
          # Use shell variables to ensure correct interpolation
          EXPENSE_IMAGE="${{ needs.build.outputs.expense_image }}"
          USER_IMAGE="${{ needs.build.outputs.user_image }}"
          FRONTEND_IMAGE="${{ needs.build.outputs.frontend_image }}"
          
          echo "Expense Service Image: $EXPENSE_IMAGE"
          echo "User Service Image: $USER_IMAGE"
          echo "Frontend Image: $FRONTEND_IMAGE"
          
          # Check if variables are empty before running kubectl commands
          if [ -n "$EXPENSE_IMAGE" ]; then
            kubectl set image deployment/expense-service expense-service="$EXPENSE_IMAGE"
          else
            echo "Error: Expense Service image name is empty. Skipping deployment."
            exit 1
          fi
          
          if [ -n "$USER_IMAGE" ]; then
            kubectl set image deployment/user-service user-service="$USER_IMAGE"
          else
            echo "Error: User Service image name is empty. Skipping deployment."
            exit 1
          fi
          
          if [ -n "$FRONTEND_IMAGE" ]; then
            kubectl set image deployment/frontend frontend="$FRONTEND_IMAGE"
          else
            echo "Error: Frontend image name is empty. Skipping deployment."
            exit 1
          fi
      # ---------------- APPLY OTHER MANIFESTS ----------------
      - name: Apply Remaining Manifests
        run: |
          kubectl apply -f k8s/mysql-configmap.yaml
          kubectl apply -f k8s/mysql-pv.yaml
          kubectl apply -f k8s/mysql-pvc.yaml
          kubectl apply -f k8s/mysql-statefulset.yaml
          kubectl apply -f k8s/mysql-service.yaml
          kubectl apply -R -f k8s/hpa/
          kubectl apply -f k8s/ingress.yaml
          kubectl apply -R -f k8s/network_policies/
      # ---------------- VERIFY ----------------
      - name: Verify Deployment
        run: |
          kubectl get pods -o wide
          kubectl get svc -o wide
          kubectl get ingress -o wide
