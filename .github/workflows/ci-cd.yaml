name: CI-CD to Kubernetes

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:

  # ---------------- JOB 1: BUILD & PUSH IMAGES ----------------
  build:
    runs-on: self-hosted
    outputs:
      expense_image: ${{ steps.expense.outputs.image }}
      user_image: ${{ steps.user.outputs.image }}
      frontend_image: ${{ steps.frontend.outputs.image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build & Push Expense Service Image
        id: expense
        run: |
          SHORT_SHA=$(echo "$GITHUB_SHA" | cut -c1-7)
          IMAGE="$DOCKER_USERNAME/expense-service:$SHORT_SHA"
          docker build -t $IMAGE ./expense-service
          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}

      - name: Build & Push User Service Image
        id: user
        run: |
          SHORT_SHA=$(echo "$GITHUB_SHA" | cut -c1-7)
          IMAGE="$DOCKER_USERNAME/user-service:$SHORT_SHA"
          docker build -t $IMAGE ./user-service
          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}

      - name: Build & Push Frontend Image
        id: frontend
        run: |
          SHORT_SHA=$(echo "$GITHUB_SHA" | cut -c1-7)
          IMAGE="$DOCKER_USERNAME/frontend-new:$SHORT_SHA"
          docker build -t $IMAGE ./frontend-new
          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}

  # ---------------- JOB 2: DEPLOY TO KUBERNETES ----------------
  deploy:
    runs-on: self-hosted
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # ---------------- INGRESS CONTROLLER ----------------
      - name: Install NGINX Ingress Controller
        run: |
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml
          kubectl wait --namespace ingress-nginx \
            --for=condition=available deployment ingress-nginx-controller \
            --timeout=180s

      - name: Patch Ingress Controller Service to NodePort
        run: |
          kubectl get svc ingress-nginx-controller -n ingress-nginx -o yaml \
            | sed 's/type: LoadBalancer/type: NodePort/' \
            | kubectl apply -f -

      # ---------------- METRICS SERVER ----------------
      - name: Install Metrics Server
        run: |
          kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
          kubectl wait --namespace kube-system \
            --for=condition=available deployment metrics-server \
            --timeout=120s

      - name: Patch Metrics Server
        run: |
          kubectl -n kube-system patch deployment metrics-server --type='json' \
            -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-insecure-tls"}]' || true
          kubectl -n kube-system rollout status deployment/metrics-server --timeout=120s || true

      # ---------------- MYSQL SECRET ----------------
      - name: Create MySQL Secret
        run: |
          kubectl delete secret mysql-secret --ignore-not-found
          kubectl create secret generic mysql-secret \
            --from-literal=MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}" \
            --from-literal=MYSQL_USER="${{ secrets.MYSQL_USER }}" \
            --from-literal=MYSQL_PASSWORD="${{ secrets.MYSQL_PASSWORD }}" \
            --from-literal=MYSQL_DATABASE="${{ secrets.MYSQL_DATABASE }}"

      # ---------------- APPLY MANIFESTS ----------------
      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f k8s/mysql-configmap.yaml
          kubectl apply -f k8s/mysql-pv.yaml
          kubectl apply -f k8s/mysql-pvc.yaml
          kubectl apply -f k8s/mysql-statefulset.yaml
          kubectl apply -f k8s/mysql-service.yaml
          kubectl apply -f k8s/expense-service.yaml
          kubectl apply -f k8s/user-service.yaml
          kubectl apply -f k8s/frontend.yaml
          kubectl apply -R -f k8s/hpa/
          kubectl apply -f k8s/ingress.yaml
          kubectl apply -R -f k8s/network_policies/

      # ---------------- UPDATE DEPLOYMENTS WITH SHA IMAGES ----------------
      - name: Update Deployments with SHA-tagged Images
        run: |
          kubectl set image deployment/expense-service expense-service=${{ needs.build.outputs.expense_image }}
          kubectl set image deployment/user-service user-service=${{ needs.build.outputs.user_image }}
          kubectl set image deployment/frontend frontend=${{ needs.build.outputs.frontend_image }}
          kubectl rollout status deployment/expense-service
          kubectl rollout status deployment/user-service
          kubectl rollout status deployment/frontend

      # ---------------- VERIFY ----------------
      - name: Verify Deployment
        run: |
          kubectl get pods -o wide
          kubectl get svc -o wide
          kubectl get ingress
